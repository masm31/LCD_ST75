
#include "ST75161.h"
#include <stdio.h> // For printf (if using semihosting or UART)
#include <stdint.h>
#include <stdbool.h>  // For boolean data type (bool, true, false)
uint8_t lcd_buffer[20][160];  // 20 row groups, 160 columns
uint8_t lcd_buffer_gray[(160 * 160) / 4];  // 2-bit per pixel, 6400 bytes
#define LCD_WIDTH  160
#define LCD_HEIGHT 160
#define FRAMEBUFFER_SIZE ((LCD_WIDTH * LCD_HEIGHT) / 4)  // 6400 bytes

uint8_t pgm_read_byte(const uint8_t *addr);

uint8_t framebuffer[FRAMEBUFFER_SIZE];  // Allocate framebuffer

const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 Space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // 33 !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34 "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // 35 #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36 $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37 %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38 &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39 '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40 (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41 )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // 42 *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // 43 +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44 ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45 -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46 .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47 /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58 :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 59 ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // 60 <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61 =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // 62 >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63 ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // 64 @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65 A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66 B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67 C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68 D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69 E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // 70 F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // 71 G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72 H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73 I
    {0x30, 0x40, 0x40, 0x40, 0x3F}, // 74 J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75 K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76 L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // 77 M
    {0x7F, 0x06, 0x08, 0x30, 0x7F}, // 78 N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79 O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80 P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81 Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82 R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83 S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84 T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85 U
    {0x0F, 0x30, 0x40, 0x30, 0x0F}, // 86 V
    {0x7F, 0x20, 0x18, 0x20, 0x7F}, // 87 W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // 88 X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // 89 Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // 90 Z
    {0x00, 0x7F, 0x41, 0x41, 0x00}, // 91 [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92 '\'
    {0x00, 0x41, 0x41, 0x7F, 0x00}, // 93 ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94 ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // 95 _
    {0x00, 0x01, 0x02, 0x04, 0x00}, // 96 `
    {0x20, 0x54, 0x54, 0x78, 0x40}, // 97 a
    {0x7F, 0x48, 0x44, 0x44, 0x38}, // 98 b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 99 c
    {0x38, 0x44, 0x44, 0x48, 0x7F}, // 100 d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 101 e
    {0x08, 0x7E, 0x09, 0x01, 0x02}, // 102 f
    {0x18, 0xA4, 0xA4, 0xA4, 0x7C}, // 103 g
    {0x7F, 0x08, 0x04, 0x04, 0x78}, // 104 h
    {0x00, 0x44, 0x7D, 0x40, 0x00}, // 105 i
    {0x20, 0x40, 0x40, 0x40, 0x1F}, // 106 j
    {0x7F, 0x10, 0x28, 0x44, 0x00}, // 107 k
    {0x00, 0x41, 0x7F, 0x40, 0x00}, // 108 l
    {0x7C, 0x04, 0x18, 0x04, 0x78}, // 109 m
    {0x7C, 0x08, 0x04, 0x04, 0x78}, // 110 n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 111 o
    {0x7C, 0x14, 0x14, 0x14, 0x08}, // 112 p
    {0x08, 0x14, 0x14, 0x18, 0x7C}, // 113 q
    {0x7C, 0x08, 0x04, 0x04, 0x08}, // 114 r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 115 s
    {0x04, 0x3F, 0x44, 0x40, 0x20}, // 116 t
    {0x3C, 0x40, 0x40, 0x20, 0x7C}, // 117 u
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, // 118 v
    {0x3C, 0x40, 0x30, 0x40, 0x3C}, // 119 w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 120 x
    {0x0C, 0x50, 0x50, 0x50, 0x3C}, // 121 y
    {0x44, 0x64, 0x54, 0x4C, 0x44}, // 122 z
    {0x00, 0x08, 0x36, 0x41, 0x00}, // 123 {
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // 124 |
    {0x00, 0x41, 0x36, 0x08, 0x00}, // 125 }
    {0x08, 0x08, 0x2A, 0x1C, 0x08}, // 126 ~
    {0x7F, 0x41, 0x41, 0x41, 0x7F}, // 127 DEL
};



const uint8_t font5x7_bold[][5] = {
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // 32 Space (bolded as a thicker line if needed, but kept blank)
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // 33 ! (thickened vertical line)
    {0x00, 0x0F, 0x00, 0x0F, 0x00}, // 34 " (thicker dots)
    {0x3C, 0xFF, 0x3C, 0xFF, 0x3C}, // 35 # (thicker hash)
    {0x3C, 0x7F, 0xFF, 0x7F, 0x1E}, // 36 $ (thicker S shape)
    {0x3F, 0x1F, 0x0C, 0xFC, 0x7E}, // 37 % (thicker strokes)
    {0x7E, 0x7F, 0x7F, 0x66, 0x78}, // 38 & (thicker curves)
    {0x00, 0x0F, 0x07, 0x00, 0x00}, // 39 ' (thicker dot)
    {0x00, 0x3E, 0x7F, 0x7F, 0x00}, // 40 ( (thicker curve)
    {0x00, 0x7F, 0x7F, 0x3E, 0x00}, // 41 ) (thicker curve)
    {0x3C, 0x1C, 0x7E, 0x1C, 0x3C}, // 42 * (thicker star)
    {0x1C, 0x1C, 0x7E, 0x1C, 0x1C}, // 43 + (thicker cross)
    {0x00, 0x70, 0x78, 0x00, 0x00}, // 44 , (thicker dot)
    {0x1C, 0x1C, 0x1C, 0x1C, 0x1C}, // 45 - (thicker line)
    {0x00, 0x78, 0x78, 0x00, 0x00}, // 46 . (thicker dot)
    {0x70, 0x38, 0x1C, 0x0E, 0x06}, // 47 / (thicker diagonal)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x7E}, // 48 0 (thicker circle)
    {0x00, 0x7E, 0xFF, 0x60, 0x00}, // 49 1 (thicker vertical)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x7E}, // 50 2 (thicker shape)
    {0x3E, 0xFF, 0xFF, 0xFF, 0x3C}, // 51 3 (thicker shape)
    {0x3C, 0x3E, 0x3F, 0xFF, 0x30}, // 52 4 (thicker vertical)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x3E}, // 53 5 (thicker shape)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x3C}, // 54 6 (thicker shape)
    {0x03, 0xFF, 0x1F, 0x07, 0x01}, // 55 7 (thicker diagonal)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x7E}, // 56 8 (thicker circle)
    {0x0E, 0xFF, 0xFF, 0xFF, 0x7E}, // 57 9 (thicker shape)
    {0x00, 0x7E, 0x7E, 0x00, 0x00}, // 58 : (thicker dots)
    {0x00, 0xFE, 0x7E, 0x00, 0x00}, // 59 ; (thicker dot with tail)
    {0x1C, 0x3E, 0x7F, 0x7F, 0x00}, // 60 < (thicker arrow)
    {0x3E, 0x3E, 0x3E, 0x3E, 0x3E}, // 61 = (thicker line)
    {0x00, 0x7F, 0x7F, 0x3E, 0x1C}, // 62 > (thicker arrow)
    {0x06, 0x03, 0xFF, 0x0F, 0x0C}, // 63 ? (thicker shape)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x7E}, // 64 @ (thicker circle)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 65 A (thicker triangle)
    {0xFF, 0xFF, 0xFF, 0xFF, 0x7E}, // 66 B (thicker shape)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x66}, // 67 C (thicker curve)
    {0xFF, 0xFF, 0xFF, 0xFF, 0x7E}, // 68 D (thicker shape)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 69 E (thicker rectangle)
    {0xFF, 0xFF, 0xFF, 0xFF, 0x01}, // 70 F (thicker top)
    {0x7E, 0xFF, 0xFF, 0xFF, 0xFE}, // 71 G (thicker shape)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 72 H (thicker rectangle)
    {0x00, 0xFF, 0xFF, 0xFF, 0x00}, // 73 I (thicker vertical)
    {0x78, 0xFC, 0xFC, 0xFC, 0xFF}, // 74 J (thicker hook)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 75 K (thicker diagonal)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 76 L (thicker vertical)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 77 M (thicker wide shape)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 78 N (thicker shape)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x7E}, // 79 O (thicker circle)
    {0xFF, 0xFF, 0xFF, 0xFF, 0x0E}, // 80 P (thicker top)
    {0x7E, 0xFF, 0xFF, 0xFF, 0xFE}, // 81 Q (thicker with tail)
    {0xFF, 0xFF, 0xFF, 0xFF, 0x7E}, // 82 R (thicker shape)
    {0x7E, 0xFF, 0xFF, 0xFF, 0x3C}, // 83 S (thicker curve)
    {0x03, 0x03, 0xFF, 0x03, 0x03}, // 84 T (thicker cross)
    {0x7F, 0xFF, 0xFF, 0xFF, 0x7F}, // 85 U (thicker U)
    {0x1F, 0x7F, 0xFF, 0x7F, 0x1F}, // 86 V (thicker V)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 87 W (thicker wide shape)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 88 X (thicker X)
    {0x0F, 0x1F, 0xFF, 0x1F, 0x0F}, // 89 Y (thicker Y)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 90 Z (thicker zigzag)
    {0x00, 0xFF, 0xFF, 0xFF, 0x00}, // 91 [ (thicker vertical)
    {0x06, 0x0E, 0x1C, 0x38, 0x70}, // 92 \ (thicker diagonal)
    {0x00, 0xFF, 0xFF, 0xFF, 0x00}, // 93 ] (thicker vertical)
    {0x0E, 0x07, 0x03, 0x07, 0x0E}, // 94 ^ (thicker hat)
    {0x7F, 0x7F, 0x7F, 0x7F, 0x7F}, // 95 _ (thicker line)
    {0x00, 0x03, 0x07, 0x0E, 0x00}, // 96 ` (thicker accent)
    {0x7C, 0xFE, 0xFE, 0xFE, 0x78}, // 97 a (thicker shape)
    {0xFF, 0xFE, 0xFE, 0xFE, 0x78}, // 98 b (thicker shape)
    {0x78, 0xFE, 0xFE, 0xFE, 0x60}, // 99 c (thicker curve)
    {0x78, 0xFE, 0xFE, 0xFE, 0xFF}, // 100 d (thicker shape)
    {0x78, 0xFE, 0xFE, 0xFE, 0x38}, // 101 e (thicker shape)
    {0x1C, 0xFF, 0x1F, 0x03, 0x06}, // 102 f (thicker top)
    {0x38, 0xFE, 0xFE, 0xFE, 0xFC}, // 103 g (thicker with tail)
    {0xFF, 0xFF, 0xFE, 0xFE, 0xF8}, // 104 h (thicker shape)
    {0x00, 0xFE, 0xFF, 0xE0, 0x00}, // 105 i (thicker vertical)
    {0x78, 0xF0, 0xF0, 0xF0, 0xFF}, // 106 j (thicker with tail)
    {0xFF, 0xFF, 0xFE, 0xFE, 0x00}, // 107 k (thicker diagonal)
    {0x00, 0xFF, 0xFF, 0xE0, 0x00}, // 108 l (thicker vertical)
    {0xFC, 0xFE, 0xFE, 0xFE, 0xF8}, // 109 m (thicker wide shape)
    {0xFC, 0xFE, 0xFE, 0xFE, 0xF8}, // 110 n (thicker shape)
    {0x78, 0xFE, 0xFE, 0xFE, 0x78}, // 111 o (thicker circle)
    {0xFC, 0xFE, 0xFE, 0xFE, 0x18}, // 112 p (thicker with tail)
    {0x18, 0xFE, 0xFE, 0xFE, 0xFC}, // 113 q (thicker with tail)
    {0xFC, 0xFE, 0xFE, 0xFE, 0x18}, // 114 r (thicker shape)
    {0x78, 0xFE, 0xFE, 0xFE, 0x60}, // 115 s (thicker curve)
    {0x0E, 0xFF, 0xFE, 0xE0, 0x70}, // 116 t (thicker cross)
    {0x7C, 0xFE, 0xFE, 0xFE, 0xFC}, // 117 u (thicker U)
    {0x3C, 0x7E, 0xFE, 0x7E, 0x3C}, // 118 v (thicker V)
    {0x7C, 0xFE, 0xFE, 0xFE, 0x7C}, // 119 w (thicker wide shape)
    {0xFE, 0xFE, 0xFE, 0xFE, 0xFE}, // 120 x (thicker X)
    {0x1C, 0xFE, 0xFE, 0xFE, 0x7C}, // 121 y (thicker with tail)
    {0xFE, 0xFE, 0xFE, 0xFE, 0xFE}, // 122 z (thicker zigzag)
    {0x00, 0x1E, 0xFF, 0xFF, 0x00}, // 123 { (thicker curve)
    {0x00, 0x00, 0xFF, 0x00, 0x00}, // 124 | (thicker vertical)
    {0x00, 0xFF, 0xFF, 0x1E, 0x00}, // 125 } (thicker curve)
    {0x1C, 0x1C, 0xFE, 0x3E, 0x1C}, // 126 ~ (thicker wave)
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // 127 DEL (thicker box)
};

const uint8_t font5x7_small[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 Space
    {0x00, 0x00, 0x5E, 0x00, 0x00}, // 33 ! (thin vertical line, centered)
    {0x00, 0x06, 0x00, 0x06, 0x00}, // 34 " (two dots, centered)
    {0x00, 0x14, 0x7F, 0x14, 0x00}, // 35 # (hash, centered)
    {0x00, 0x2E, 0x6B, 0x3A, 0x00}, // 36 $ (S shape, compressed)
    {0x00, 0x22, 0x08, 0x11, 0x00}, // 37 % (diagonal with dots)
    {0x00, 0x34, 0x4A, 0x31, 0x00}, // 38 & (compressed ampersand)
    {0x00, 0x00, 0x06, 0x00, 0x00}, // 39 ' (single dot, centered)
    {0x00, 0x00, 0x3C, 0x42, 0x00}, // 40 ( (open paren, centered)
    {0x00, 0x42, 0x3C, 0x00, 0x00}, // 41 ) (close paren, centered)
    {0x00, 0x14, 0x08, 0x14, 0x00}, // 42 * (star, centered)
    {0x00, 0x08, 0x3E, 0x08, 0x00}, // 43 + (plus, centered)
    {0x00, 0x40, 0x20, 0x00, 0x00}, // 44 , (comma, centered)
    {0x00, 0x08, 0x08, 0x08, 0x00}, // 45 - (dash, centered)
    {0x00, 0x00, 0x40, 0x00, 0x00}, // 46 . (dot, centered)
    {0x00, 0x20, 0x10, 0x08, 0x00}, // 47 / (diagonal, centered)
    {0x00, 0x3C, 0x44, 0x3C, 0x00}, // 48 0 (circle, centered)
    {0x00, 0x40, 0x7C, 0x00, 0x00}, // 49 1 (vertical, centered)
    {0x00, 0x64, 0x54, 0x48, 0x00}, // 50 2 (compressed, centered)
    {0x00, 0x44, 0x54, 0x2C, 0x00}, // 51 3 (compressed, centered)
    {0x00, 0x18, 0x14, 0x7C, 0x00}, // 52 4 (compressed, centered)
    {0x00, 0x4C, 0x54, 0x24, 0x00}, // 53 5 (compressed, centered)
    {0x00, 0x38, 0x54, 0x24, 0x00}, // 54 6 (compressed, centered)
    {0x00, 0x04, 0x74, 0x0C, 0x00}, // 55 7 (compressed, centered)
    {0x00, 0x2C, 0x54, 0x2C, 0x00}, // 56 8 (compressed, centered)
    {0x00, 0x48, 0x54, 0x3C, 0x00}, // 57 9 (compressed, centered)
    {0x00, 0x00, 0x28, 0x00, 0x00}, // 58 : (dots, centered)
    {0x00, 0x40, 0x28, 0x00, 0x00}, // 59 ; (dot with tail, centered)
    {0x00, 0x10, 0x28, 0x44, 0x00}, // 60 < (less than, centered)
    {0x00, 0x14, 0x14, 0x14, 0x00}, // 61 = (equals, centered)
    {0x00, 0x44, 0x28, 0x10, 0x00}, // 62 > (greater than, centered)
    {0x00, 0x04, 0x54, 0x08, 0x00}, // 63 ? (compressed, centered)
    {0x00, 0x3C, 0x5C, 0x2C, 0x00}, // 64 @ (compressed, centered)
    {0x00, 0x78, 0x14, 0x78, 0x00}, // 65 A (triangle, centered)
    {0x00, 0x7C, 0x54, 0x28, 0x00}, // 66 B (compressed, centered)
    {0x00, 0x38, 0x44, 0x44, 0x00}, // 67 C (curve, centered)
    {0x00, 0x7C, 0x44, 0x38, 0x00}, // 68 D (compressed, centered)
    {0x00, 0x7C, 0x54, 0x44, 0x00}, // 69 E (compressed, centered)
    {0x00, 0x7C, 0x14, 0x04, 0x00}, // 70 F (compressed, centered)
    {0x00, 0x38, 0x44, 0x2C, 0x00}, // 71 G (compressed, centered)
    {0x00, 0x7C, 0x10, 0x7C, 0x00}, // 72 H (compressed, centered)
    {0x00, 0x44, 0x7C, 0x44, 0x00}, // 73 I (vertical, centered)
    {0x00, 0x20, 0x40, 0x3C, 0x00}, // 74 J (compressed, centered)
    {0x00, 0x7C, 0x28, 0x44, 0x00}, // 75 K (compressed, centered)
    {0x00, 0x7C, 0x40, 0x40, 0x00}, // 76 L (compressed, centered)
    {0x00, 0x7C, 0x08, 0x7C, 0x00}, // 77 M (compressed, centered)
    {0x00, 0x7C, 0x08, 0x7C, 0x00}, // 78 N (compressed, centered)
    {0x00, 0x38, 0x44, 0x38, 0x00}, // 79 O (circle, centered)
    {0x00, 0x7C, 0x14, 0x08, 0x00}, // 80 P (compressed, centered)
    {0x00, 0x38, 0x64, 0x58, 0x00}, // 81 Q (compressed, centered)
    {0x00, 0x7C, 0x14, 0x68, 0x00}, // 82 R (compressed, centered)
    {0x00, 0x48, 0x54, 0x24, 0x00}, // 83 S (compressed, centered)
    {0x00, 0x04, 0x7C, 0x04, 0x00}, // 84 T (compressed, centered)
    {0x00, 0x7C, 0x40, 0x7C, 0x00}, // 85 U (compressed, centered)
    {0x00, 0x3C, 0x40, 0x3C, 0x00}, // 86 V (compressed, centered)
    {0x00, 0x7C, 0x20, 0x7C, 0x00}, // 87 W (compressed, centered)
    {0x00, 0x6C, 0x10, 0x6C, 0x00}, // 88 X (compressed, centered)
    {0x00, 0x0C, 0x70, 0x0C, 0x00}, // 89 Y (compressed, centered)
    {0x00, 0x64, 0x54, 0x4C, 0x00}, // 90 Z (compressed, centered)
    {0x00, 0x00, 0x7C, 0x44, 0x00}, // 91 [ (compressed, centered)
    {0x00, 0x04, 0x08, 0x10, 0x00}, // 92 \ (diagonal, centered)
    {0x00, 0x44, 0x7C, 0x00, 0x00}, // 93 ] (compressed, centered)
    {0x00, 0x08, 0x04, 0x08, 0x00}, // 94 ^ (hat, centered)
    {0x00, 0x40, 0x40, 0x40, 0x00}, // 95 _ (underline, centered)
    {0x00, 0x00, 0x04, 0x08, 0x00}, // 96 ` (accent, centered)
    {0x00, 0x30, 0x48, 0x78, 0x00}, // 97 a (compressed, centered)
    {0x00, 0x78, 0x44, 0x38, 0x00}, // 98 b (compressed, centered)
    {0x00, 0x30, 0x48, 0x48, 0x00}, // 99 c (compressed, centered)
    {0x00, 0x38, 0x44, 0x78, 0x00}, // 100 d (compressed, centered)
    {0x00, 0x30, 0x58, 0x58, 0x00}, // 101 e (compressed, centered)
    {0x00, 0x08, 0x7C, 0x0C, 0x00}, // 102 f (compressed, centered)
    {0x00, 0x30, 0x48, 0x78, 0x00}, // 103 g (compressed, centered)
    {0x00, 0x78, 0x08, 0x70, 0x00}, // 104 h (compressed, centered)
    {0x00, 0x00, 0x74, 0x00, 0x00}, // 105 i (vertical, centered)
    {0x00, 0x40, 0x38, 0x00, 0x00}, // 106 j (compressed, centered)
    {0x00, 0x78, 0x20, 0x58, 0x00}, // 107 k (compressed, centered)
    {0x00, 0x00, 0x7C, 0x00, 0x00}, // 108 l (vertical, centered)
    {0x00, 0x78, 0x30, 0x78, 0x00}, // 109 m (compressed, centered)
    {0x00, 0x78, 0x08, 0x70, 0x00}, // 110 n (compressed, centered)
    {0x00, 0x30, 0x48, 0x30, 0x00}, // 111 o (circle, centered)
    {0x00, 0x78, 0x48, 0x30, 0x00}, // 112 p (compressed, centered)
    {0x00, 0x30, 0x48, 0x78, 0x00}, // 113 q (compressed, centered)
    {0x00, 0x78, 0x08, 0x08, 0x00}, // 114 r (compressed, centered)
    {0x00, 0x58, 0x54, 0x34, 0x00}, // 115 s (compressed, centered)
    {0x00, 0x08, 0x7C, 0x48, 0x00}, // 116 t (compressed, centered)
    {0x00, 0x78, 0x40, 0x78, 0x00}, // 117 u (compressed, centered)
    {0x00, 0x38, 0x40, 0x38, 0x00}, // 118 v (compressed, centered)
    {0x00, 0x78, 0x60, 0x78, 0x00}, // 119 w (compressed, centered)
    {0x00, 0x58, 0x20, 0x58, 0x00}, // 120 x (compressed, centered)
    {0x00, 0x38, 0x40, 0x38, 0x00}, // 121 y (compressed, centered)
    {0x00, 0x68, 0x54, 0x5C, 0x00}, // 122 z (compressed, centered)
    {0x00, 0x08, 0x34, 0x42, 0x00}, // 123 { (compressed, centered)
    {0x00, 0x00, 0x7C, 0x00, 0x00}, // 124 | (vertical, centered)
    {0x00, 0x42, 0x34, 0x08, 0x00}, // 125 } (compressed, centered)
    {0x00, 0x08, 0x14, 0x08, 0x00}, // 126 ~ (wave, centered)
    {0x00, 0x7C, 0x54, 0x7C, 0x00}, // 127 DEL (box, centered)
};
const uint8_t font5x7_italic[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 Space
    {0x00, 0x00, 0x2E, 0x00, 0x00}, // 33 ! (slanted vertical)
    {0x00, 0x03, 0x00, 0x0C, 0x00}, // 34 " (slanted dots)
    {0x00, 0x08, 0x3E, 0x08, 0x00}, // 35 # (slanted hash)
    {0x00, 0x14, 0x35, 0x1C, 0x00}, // 36 $ (slanted S shape)
    {0x00, 0x11, 0x04, 0x08, 0x00}, // 37 % (slanted diagonal)
    {0x00, 0x1C, 0x25, 0x18, 0x00}, // 38 & (slanted curve)
    {0x00, 0x00, 0x03, 0x00, 0x00}, // 39 ' (slanted dot)
    {0x00, 0x00, 0x1C, 0x21, 0x00}, // 40 ( (slanted open paren)
    {0x00, 0x21, 0x1C, 0x00, 0x00}, // 41 ) (slanted close paren)
    {0x00, 0x08, 0x04, 0x08, 0x00}, // 42 * (slanted star)
    {0x00, 0x04, 0x1F, 0x04, 0x00}, // 43 + (slanted cross)
    {0x00, 0x20, 0x10, 0x00, 0x00}, // 44 , (slanted comma)
    {0x00, 0x04, 0x04, 0x04, 0x00}, // 45 - (slanted line)
    {0x00, 0x00, 0x20, 0x00, 0x00}, // 46 . (slanted dot)
    {0x00, 0x10, 0x08, 0x04, 0x00}, // 47 / (slanted diagonal)
    {0x00, 0x1C, 0x22, 0x1C, 0x00}, // 48 0 (slanted circle)
    {0x00, 0x20, 0x3E, 0x00, 0x00}, // 49 1 (slanted vertical)
    {0x00, 0x32, 0x2A, 0x24, 0x00}, // 50 2 (slanted shape)
    {0x00, 0x22, 0x2A, 0x16, 0x00}, // 51 3 (slanted shape)
    {0x00, 0x0C, 0x0A, 0x3E, 0x00}, // 52 4 (slanted vertical)
    {0x00, 0x26, 0x2A, 0x12, 0x00}, // 53 5 (slanted shape)
    {0x00, 0x1C, 0x2A, 0x12, 0x00}, // 54 6 (slanted shape)
    {0x00, 0x02, 0x3A, 0x06, 0x00}, // 55 7 (slanted diagonal)
    {0x00, 0x16, 0x2A, 0x16, 0x00}, // 56 8 (slanted circle)
    {0x00, 0x24, 0x2A, 0x1C, 0x00}, // 57 9 (slanted shape)
    {0x00, 0x00, 0x14, 0x00, 0x00}, // 58 : (slanted dots)
    {0x00, 0x20, 0x14, 0x00, 0x00}, // 59 ; (slanted dot with tail)
    {0x00, 0x08, 0x14, 0x22, 0x00}, // 60 < (slanted arrow)
    {0x00, 0x0A, 0x0A, 0x0A, 0x00}, // 61 = (slanted line)
    {0x00, 0x22, 0x14, 0x08, 0x00}, // 62 > (slanted arrow)
    {0x00, 0x02, 0x2A, 0x04, 0x00}, // 63 ? (slanted shape)
    {0x00, 0x1C, 0x2E, 0x16, 0x00}, // 64 @ (slanted circle)
    {0x00, 0x3C, 0x0A, 0x3C, 0x00}, // 65 A (slanted triangle)
    {0x00, 0x3E, 0x2A, 0x14, 0x00}, // 66 B (slanted shape)
    {0x00, 0x1C, 0x22, 0x22, 0x00}, // 67 C (slanted curve)
    {0x00, 0x3E, 0x22, 0x1C, 0x00}, // 68 D (slanted shape)
    {0x00, 0x3E, 0x2A, 0x22, 0x00}, // 69 E (slanted rectangle)
    {0x00, 0x3E, 0x0A, 0x02, 0x00}, // 70 F (slanted top)
    {0x00, 0x1C, 0x22, 0x16, 0x00}, // 71 G (slanted shape)
    {0x00, 0x3E, 0x08, 0x3E, 0x00}, // 72 H (slanted rectangle)
    {0x00, 0x22, 0x3E, 0x22, 0x00}, // 73 I (slanted vertical)
    {0x00, 0x10, 0x20, 0x1E, 0x00}, // 74 J (slanted hook)
    {0x00, 0x3E, 0x14, 0x22, 0x00}, // 75 K (slanted diagonal)
    {0x00, 0x3E, 0x20, 0x20, 0x00}, // 76 L (slanted vertical)
    {0x00, 0x3E, 0x04, 0x3E, 0x00}, // 77 M (slanted wide shape)
    {0x00, 0x3E, 0x04, 0x3E, 0x00}, // 78 N (slanted shape)
    {0x00, 0x1C, 0x22, 0x1C, 0x00}, // 79 O (slanted circle)
    {0x00, 0x3E, 0x0A, 0x04, 0x00}, // 80 P (slanted top)
    {0x00, 0x1C, 0x32, 0x2C, 0x00}, // 81 Q (slanted with tail)
    {0x00, 0x3E, 0x0A, 0x34, 0x00}, // 82 R (slanted shape)
    {0x00, 0x24, 0x2A, 0x12, 0x00}, // 83 S (slanted curve)
    {0x00, 0x02, 0x3E, 0x02, 0x00}, // 84 T (slanted cross)
    {0x00, 0x3E, 0x20, 0x3E, 0x00}, // 85 U (slanted U)
    {0x00, 0x1E, 0x20, 0x1E, 0x00}, // 86 V (slanted V)
    {0x00, 0x3E, 0x10, 0x3E, 0x00}, // 87 W (slanted wide shape)
    {0x00, 0x36, 0x08, 0x36, 0x00}, // 88 X (slanted X)
    {0x00, 0x06, 0x38, 0x06, 0x00}, // 89 Y (slanted Y)
    {0x00, 0x32, 0x2A, 0x26, 0x00}, // 90 Z (slanted zigzag)
    {0x00, 0x00, 0x3E, 0x22, 0x00}, // 91 [ (slanted vertical)
    {0x00, 0x02, 0x04, 0x08, 0x00}, // 92 \ (slanted diagonal)
    {0x00, 0x22, 0x3E, 0x00, 0x00}, // 93 ] (slanted vertical)
    {0x00, 0x04, 0x02, 0x04, 0x00}, // 94 ^ (slanted hat)
    {0x00, 0x20, 0x20, 0x20, 0x00}, // 95 _ (slanted line)
    {0x00, 0x00, 0x02, 0x04, 0x00}, // 96 ` (slanted accent)
    {0x00, 0x18, 0x24, 0x3C, 0x00}, // 97 a (slanted shape)
    {0x00, 0x3C, 0x24, 0x1C, 0x00}, // 98 b (slanted shape)
    {0x00, 0x18, 0x24, 0x24, 0x00}, // 99 c (slanted curve)
    {0x00, 0x1C, 0x24, 0x3C, 0x00}, // 100 d (slanted shape)
    {0x00, 0x18, 0x2C, 0x2C, 0x00}, // 101 e (slanted shape)
    {0x00, 0x04, 0x3E, 0x06, 0x00}, // 102 f (slanted top)
    {0x00, 0x18, 0x24, 0x3C, 0x00}, // 103 g (slanted with tail)
    {0x00, 0x3C, 0x04, 0x38, 0x00}, // 104 h (slanted shape)
    {0x00, 0x00, 0x3A, 0x00, 0x00}, // 105 i (slanted vertical)
    {0x00, 0x20, 0x1C, 0x00, 0x00}, // 106 j (slanted with tail)
    {0x00, 0x3C, 0x10, 0x2C, 0x00}, // 107 k (slanted diagonal)
    {0x00, 0x00, 0x3E, 0x00, 0x00}, // 108 l (slanted vertical)
    {0x00, 0x3C, 0x18, 0x3C, 0x00}, // 109 m (slanted wide shape)
    {0x00, 0x3C, 0x04, 0x38, 0x00}, // 110 n (slanted shape)
    {0x00, 0x18, 0x24, 0x18, 0x00}, // 111 o (slanted circle)
    {0x00, 0x3C, 0x24, 0x18, 0x00}, // 112 p (slanted with tail)
    {0x00, 0x18, 0x24, 0x3C, 0x00}, // 113 q (slanted with tail)
    {0x00, 0x3C, 0x04, 0x04, 0x00}, // 114 r (slanted shape)
    {0x00, 0x2C, 0x2A, 0x1A, 0x00}, // 115 s (slanted curve)
    {0x00, 0x04, 0x3E, 0x24, 0x00}, // 116 t (slanted cross)
    {0x00, 0x3C, 0x20, 0x3C, 0x00}, // 117 u (slanted U)
    {0x00, 0x1C, 0x20, 0x1C, 0x00}, // 118 v (slanted V)
    {0x00, 0x3C, 0x30, 0x3C, 0x00}, // 119 w (slanted wide shape)
    {0x00, 0x2C, 0x10, 0x2C, 0x00}, // 120 x (slanted X)
    {0x00, 0x1C, 0x20, 0x1C, 0x00}, // 121 y (slanted with tail)
    {0x00, 0x34, 0x2A, 0x2C, 0x00}, // 122 z (slanted zigzag)
    {0x00, 0x04, 0x1A, 0x21, 0x00}, // 123 { (slanted curve)
    {0x00, 0x00, 0x3E, 0x00, 0x00}, // 124 | (slanted vertical)
    {0x00, 0x21, 0x1A, 0x04, 0x00}, // 125 } (slanted curve)
    {0x00, 0x04, 0x0A, 0x04, 0x00}, // 126 ~ (slanted wave)
    {0x00, 0x3E, 0x2A, 0x3E, 0x00}, // 127 DEL (slanted box)
};
const uint8_t font7x9[][7] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 32 Space
    {0x00, 0x00, 0x7C, 0x7C, 0x00, 0x00, 0x00}, // 33 !
    {0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00}, // 34 "
    {0x00, 0x28, 0xFE, 0x28, 0xFE, 0x28, 0x00}, // 35 #
    {0x00, 0x48, 0x54, 0xFE, 0x54, 0x24, 0x00}, // 36 $
    {0x00, 0x44, 0x14, 0x08, 0x44, 0x22, 0x00}, // 37 %
    {0x00, 0x6C, 0x92, 0xAA, 0x44, 0x28, 0x00}, // 38 &
    {0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00}, // 39 '
    {0x00, 0x00, 0x38, 0x44, 0x82, 0x00, 0x00}, // 40 (
    {0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, // 41 )
    {0x00, 0x28, 0x10, 0x7C, 0x10, 0x28, 0x00}, // 42 *
    {0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00}, // 43 +
    {0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00}, // 44 ,
    {0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00}, // 45 -
    {0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00}, // 46 .
    {0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00}, // 47 /
    {0x00, 0x7C, 0x82, 0x82, 0x82, 0x7C, 0x00}, // 48 0
    {0x00, 0x00, 0x84, 0xFE, 0x80, 0x00, 0x00}, // 49 1
    {0x00, 0x84, 0xC2, 0xA2, 0x92, 0x8C, 0x00}, // 50 2
    {0x00, 0x44, 0x82, 0x92, 0x92, 0x6C, 0x00}, // 51 3
    {0x00, 0x30, 0x28, 0x24, 0xFE, 0x20, 0x00}, // 52 4
    {0x00, 0x5E, 0x92, 0x92, 0x92, 0x62, 0x00}, // 53 5
    {0x00, 0x7C, 0x92, 0x92, 0x92, 0x64, 0x00}, // 54 6
    {0x00, 0x02, 0xE2, 0x12, 0x0A, 0x06, 0x00}, // 55 7
    {0x00, 0x6C, 0x92, 0x92, 0x92, 0x6C, 0x00}, // 56 8
    {0x00, 0x4C, 0x92, 0x92, 0x92, 0x7C, 0x00}, // 57 9
    {0x00, 0x00, 0x6C, 0x6C, 0x00, 0x00, 0x00}, // 58 :
    {0x00, 0x00, 0xAC, 0x6C, 0x00, 0x00, 0x00}, // 59 ;
    {0x00, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00}, // 60 <
    {0x00, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00}, // 61 =
    {0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x00}, // 62 >
    {0x00, 0x04, 0x02, 0xA2, 0x12, 0x0C, 0x00}, // 63 ?
    {0x00, 0x7C, 0x82, 0xBA, 0xAA, 0x7C, 0x00}, // 64 @
    {0x00, 0xFC, 0x12, 0x12, 0x12, 0xFC, 0x00}, // 65 A
    {0x00, 0xFE, 0x92, 0x92, 0x92, 0x6C, 0x00}, // 66 B
    {0x00, 0x7C, 0x82, 0x82, 0x82, 0x44, 0x00}, // 67 C
    {0x00, 0xFE, 0x82, 0x82, 0x82, 0x7C, 0x00}, // 68 D
    {0x00, 0xFE, 0x92, 0x92, 0x92, 0x82, 0x00}, // 69 E
    {0x00, 0xFE, 0x12, 0x12, 0x12, 0x02, 0x00}, // 70 F
    {0x00, 0x7C, 0x82, 0x82, 0x92, 0x74, 0x00}, // 71 G
    {0x00, 0xFE, 0x10, 0x10, 0x10, 0xFE, 0x00}, // 72 H
    {0x00, 0x00, 0x82, 0xFE, 0x82, 0x00, 0x00}, // 73 I
    {0x00, 0x40, 0x80, 0x80, 0x80, 0x7E, 0x00}, // 74 J
    {0x00, 0xFE, 0x10, 0x28, 0x44, 0x82, 0x00}, // 75 K
    {0x00, 0xFE, 0x80, 0x80, 0x80, 0x80, 0x00}, // 76 L
    {0x00, 0xFE, 0x04, 0x08, 0x04, 0xFE, 0x00}, // 77 M
    {0x00, 0xFE, 0x04, 0x08, 0x10, 0xFE, 0x00}, // 78 N
    {0x00, 0x7C, 0x82, 0x82, 0x82, 0x7C, 0x00}, // 79 O
    {0x00, 0xFE, 0x12, 0x12, 0x12, 0x0C, 0x00}, // 80 P
    {0x00, 0x7C, 0x82, 0xA2, 0x42, 0xBC, 0x00}, // 81 Q
    {0x00, 0xFE, 0x12, 0x12, 0x12, 0xEC, 0x00}, // 82 R
    {0x00, 0x4C, 0x92, 0x92, 0x92, 0x64, 0x00}, // 83 S
    {0x00, 0x02, 0x02, 0xFE, 0x02, 0x02, 0x00}, // 84 T
    {0x00, 0x7E, 0x80, 0x80, 0x80, 0x7E, 0x00}, // 85 U
    {0x00, 0x3E, 0x40, 0x80, 0x40, 0x3E, 0x00}, // 86 V
    {0x00, 0xFE, 0x20, 0x10, 0x20, 0xFE, 0x00}, // 87 W
    {0x00, 0xC6, 0x28, 0x10, 0x28, 0xC6, 0x00}, // 88 X
    {0x00, 0x0E, 0x10, 0xE0, 0x10, 0x0E, 0x00}, // 89 Y
    {0x00, 0xC2, 0xA2, 0x92, 0x8A, 0x86, 0x00}, // 90 Z
    {0x00, 0x00, 0xFE, 0x82, 0x82, 0x00, 0x00}, // 91 [
    {0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, // 92 \ ttt
    {0x00, 0x00, 0x82, 0x82, 0xFE, 0x00, 0x00}, // 93 ]
    {0x00, 0x08, 0x04, 0x02, 0x04, 0x08, 0x00}, // 94 ^
    {0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00}, // 95 _
    {0x00, 0x00, 0x02, 0x04, 0x08, 0x00, 0x00}, // 96 `
    {0x00, 0x64, 0x92, 0x92, 0x92, 0xFE, 0x00}, // 97 a
    {0x00, 0xFE, 0x88, 0x88, 0x88, 0x70, 0x00}, // 98 b
    {0x00, 0x70, 0x88, 0x88, 0x88, 0x48, 0x00}, // 99 c
    {0x00, 0x70, 0x88, 0x88, 0x88, 0xFE, 0x00}, // 100 d
		{0x00, 0x00, 0x70, 0x88, 0xF8, 0x88, 0x48}, // 101 e
    {0x00, 0x08, 0xFE, 0x0A, 0x0A, 0x04, 0x00}, // 102 f
    {0x00, 0x70, 0x88, 0x88, 0x48, 0xF8, 0x00}, // 103 g
    {0x00, 0xFE, 0x08, 0x08, 0x08, 0xF0, 0x00}, // 104 h
    {0x00, 0x00, 0x88, 0xFA, 0x80, 0x00, 0x00}, // 105 i
    {0x00, 0x40, 0x80, 0x88, 0x7A, 0x00, 0x00}, // 106 j
    {0x00, 0xFE, 0x20, 0x50, 0x88, 0x00, 0x00}, // 107 k
    {0x00, 0x00, 0x82, 0xFE, 0x80, 0x00, 0x00}, // 108 l
    {0x00, 0xF8, 0x08, 0xF0, 0x08, 0xF0, 0x00}, // 109 m
    {0x00, 0xF8, 0x08, 0x08, 0x08, 0xF0, 0x00}, // 110 n
    {0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00}, // 111 o
    {0x00, 0xF8, 0x48, 0x48, 0x48, 0x30, 0x00}, // 112 p
    {0x00, 0x30, 0x48, 0x48, 0x48, 0xF8, 0x00}, // 113 q
    {0x00, 0xF8, 0x08, 0x08, 0x08, 0x00, 0x00}, // 114 r
    {0x00, 0x30, 0x48, 0x48, 0x48, 0x90, 0x00}, // 115 s
    {0x00, 0x04, 0x7E, 0x84, 0x84, 0x40, 0x00}, // 116 t
    {0x00, 0x78, 0x80, 0x80, 0x80, 0xF8, 0x00}, // 117 u
    {0x00, 0x38, 0x40, 0x80, 0x40, 0x38, 0x00}, // 118 v
    {0x00, 0x78, 0x80, 0x70, 0x80, 0x78, 0x00}, // 119 w
    {0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00}, // 120 x
    {0x00, 0x18, 0x20, 0xC0, 0x20, 0x18, 0x00}, // 121 y
    {0x00, 0x88, 0xC8, 0xA8, 0x98, 0x88, 0x00}, // 122 z
    {0x00, 0x10, 0x7C, 0x82, 0x82, 0x00, 0x00}, // 123 {
    {0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00}, // 124 |
    {0x00, 0x00, 0x82, 0x82, 0x7C, 0x10, 0x00}, // 125 }
    {0x00, 0x0C, 0x04, 0x08, 0x04, 0x0C, 0x00}, // 126 ~
    {0x00, 0xFE, 0x82, 0x82, 0x82, 0xFE, 0x00}, // 127 DEL
};


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
const uint16_t font5x7_GRAY[][5] = {
    // ASCII 32-47: Space and Punctuation (as provided)
    {0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 32 Space
    {0x0000, 0x0C03, 0x0C03, 0x0C03, 0x0000}, // 33 !
    {0x0000, 0x000F, 0x0000, 0x000F, 0x0000}, // 34 "
    {0x0CF0, 0x3FFC, 0x0CF0, 0x3FFC, 0x0CF0}, // 35 #
    {0x0C3C, 0x3C03, 0x0FFF, 0x30C3, 0x0F0C}, // 36 $
    {0x3C0F, 0x0C3C, 0x00F0, 0x33C0, 0x0F3C}, // 37 %
    {0x0FFC, 0x30C0, 0x0F3F, 0x33C0, 0x0CFF}, // 38 &
    {0x0000, 0x0003, 0x0000, 0x0000, 0x0000}, // 39 '
    {0x0000, 0x03F0, 0x0C0C, 0x3003, 0x0000}, // 40 (
    {0x0000, 0x3003, 0x0C0C, 0x03F0, 0x0000}, // 41 )
    {0x0C30, 0x0330, 0x0FFF, 0x0330, 0x0C30}, // 42 *
    {0x0300, 0x0300, 0x0FFF, 0x0300, 0x0300}, // 43 +
    {0x0000, 0x0000, 0x0000, 0x0C00, 0x0300}, // 44 ,
    {0x0300, 0x0300, 0x0300, 0x0300, 0x0300}, // 45 -
    {0x0000, 0x0000, 0x0000, 0x0C00, 0x0C00}, // 46 .
    {0x0C00, 0x0300, 0x00C0, 0x0030, 0x000C}, // 47 /

    // ASCII 48-57: Numbers (completed)
    {0x0FFC, 0x3303, 0x30C3, 0x3033, 0x0FFC}, // 48 0
    {0x0000, 0x3030, 0x3FFF, 0x3000, 0x0000}, // 49 1
    {0x300C, 0x3C03, 0x3303, 0x30C3, 0x303C}, // 50 2
    {0x0C3C, 0x30C3, 0x30C3, 0x30C3, 0x0F03}, // 51 3
    {0x0030, 0x0CF0, 0x3FFC, 0x0C30, 0x0C30}, // 52 4
    {0x3FFC, 0x3003, 0x3FFC, 0x0003, 0x3FFC}, // 53 5
    {0x0FFC, 0x3003, 0x3FFC, 0x3003, 0x0FFC}, // 54 6
    {0x3FFF, 0x0003, 0x0003, 0x0003, 0x0003}, // 55 7
    {0x0FFC, 0x3303, 0x0FFC, 0x3303, 0x0FFC}, // 56 8
    {0x0FFC, 0x3303, 0x0FFC, 0x0003, 0x0FFC}, // 57 9

    // ASCII 58-64: Punctuation (as provided)
    {0x0000, 0x0C00, 0x0C00, 0x0000, 0x0C00}, // 58 :
    {0x0000, 0x0C00, 0x0C00, 0x0C00, 0x0300}, // 59 ;
    {0x0030, 0x00C0, 0x0300, 0x00C0, 0x0030}, // 60 <
    {0x0CC0, 0x0CC0, 0x0CC0, 0x0CC0, 0x0CC0}, // 61 =
    {0x0C00, 0x0300, 0x00C0, 0x0300, 0x0C00}, // 62 >
    {0x0FC0, 0x00C0, 0x03C0, 0x0000, 0x0C00}, // 63 ?
    {0x0FC0, 0x303F, 0x3CC3, 0x303C, 0x0F00}, // 64 @

    // ASCII 65-90: Uppercase Letters (as provided)
    {0x3FFC, 0x00C3, 0x00C3, 0x00C3, 0x3FFC}, // 65 A
    {0x3FFF, 0x30C3, 0x30C3, 0x30C3, 0x0F3C}, // 66 B
    {0x1FFC, 0x3003, 0x3003, 0x3003, 0x1C1C}, // 67 C
    {0x3FFF, 0x3003, 0x3003, 0x3003, 0x0FFC}, // 68 D
    {0x3FFF, 0x30C3, 0x30C3, 0x30C3, 0x3003}, // 69 E
    {0x3FFF, 0x00C3, 0x00C3, 0x00C3, 0x0003}, // 70 F
    {0x1FFC, 0x3003, 0x30C3, 0x30C3, 0x1FC3}, // 71 G
    {0x3FFC, 0x00C0, 0x00C0, 0x00C0, 0x3FFC}, // 72 H
    {0x0000, 0x3003, 0x3FFF, 0x3003, 0x0000}, // 73 I
    {0x1C00, 0x3000, 0x3003, 0x1FFF, 0x0003}, // 74 J
    {0x3FFC, 0x00C0, 0x03F0, 0x300C, 0x0003}, // 75 K
    {0x3FFC, 0x3000, 0x3000, 0x3000, 0x3000}, // 76 L
    {0x3FFC, 0x00F0, 0x03C0, 0x00F0, 0x3FFC}, // 77 M
    {0x3FFC, 0x00F0, 0x03C0, 0x0F00, 0x3FFC}, // 78 N
    {0x0FFC, 0x3003, 0x3003, 0x3003, 0x0FFC}, // 79 O
    {0x3FFC, 0x00C3, 0x00C3, 0x00C3, 0x003C}, // 80 P
    {0x0FFC, 0x3003, 0x3303, 0x3C03, 0x0FFC}, // 81 Q
    {0x3FFC, 0x00C3, 0x03C3, 0x0CC3, 0x303C}, // 82 R
    {0x0C3C, 0x30C3, 0x30C3, 0x30C3, 0x0F03}, // 83 S
    {0x0003, 0x0003, 0x3FFF, 0x0003, 0x0003}, // 84 T
    {0x0FFC, 0x3000, 0x3000, 0x3000, 0x0FFC}, // 85 U
    {0x03FC, 0x0C00, 0x3000, 0x0C00, 0x03FC}, // 86 V
    {0x3FFC, 0x0C00, 0x03C0, 0x0C00, 0x3FFC}, // 87 W
    {0x3C3C, 0x0CC0, 0x0300, 0x0CC0, 0x3C3C}, // 88 X
    {0x003C, 0x00C0, 0x3F00, 0x00C0, 0x003C}, // 89 Y
    {0x3C03, 0x3303, 0x30C3, 0x3033, 0x0C0F}, // 90 Z

    // ASCII 91-96: Symbols (as provided)
    {0x0000, 0x3FFF, 0x3003, 0x3003, 0x0000}, // 91 [
    {0x000C, 0x0030, 0x00C0, 0x0300, 0x0C00}, // 92 \
    {0x0000, 0x3003, 0x3003, 0x3FFF, 0x0000}, // 93 ]
    {0x0300, 0x00C0, 0x0030, 0x00C0, 0x0300}, // 94 ^
    {0x0000, 0x0000, 0x0000, 0x0000, 0x3FFF}, // 95 _
    {0x0000, 0x0003, 0x0000, 0x0000, 0x0000}, // 96 `

    // ASCII 123-127: Symbols (as provided)
    {0x00C0, 0x0F00, 0x3003, 0x0F00, 0x00C0}, // 123 {
    {0x0000, 0x0000, 0x3FFF, 0x0000, 0x0000}, // 124 |
    {0x0C00, 0x03C0, 0x3003, 0x03C0, 0x0C00}, // 125 }
    {0x0C00, 0x0300, 0x0C00, 0x0300, 0x0C00}, // 126 ~
    {0x3FFF, 0x3FFF, 0x3FFF, 0x3FFF, 0x3FFF}  // 127 DEL
};




/*------------------------------------------------------------------------------------------------------------------------------------------------*/
unsigned char  logo[]=
{
// '????', 160x160px
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0x87, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 
0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf0, 0x01, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xfe, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x60, 
0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 
0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xfe, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x8f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xe0, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 
0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 
0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xc0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
0x00, 0x7f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x01, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0x80, 0x00, 0x01, 0xff, 0xf0, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0x80, 0x00, 
0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc7, 0xff, 
0xfe, 0x0f, 0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
0xff, 0xff, 0xc7, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x87, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x87, 0xff, 0xfc, 0x00, 0x00, 0x00, 
0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x0f, 0xff, 
0xf8, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x3f, 
0xff, 0xfe, 0x0d, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf0, 0x00, 0x1f, 0xff, 0xfe, 0x0d, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x1f, 0xff, 0xfc, 0x1b, 0xff, 0xf0, 0x00, 0x00, 0x00, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xfc, 0x1b, 0xff, 
0xf0, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 
0xff, 0xec, 0x13, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0x80, 0x07, 0xff, 0xe8, 0x13, 0xff, 0xfe, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xd8, 0x03, 0xff, 0xff, 0x80, 0x00, 0x03, 
0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x03, 0xff, 0xd8, 0x03, 0xff, 
0xff, 0xc0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xe0, 0x03, 
0xff, 0xd8, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xf0, 0x03, 0xff, 0xd8, 0x01, 0xbf, 0xff, 0xc0, 0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x03, 0xff, 0x88, 0x01, 0x9f, 0xff, 0xc0, 0x00, 0x0f, 
0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x01, 0xff, 0x88, 0x00, 0xdf, 
0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x01, 
0xfe, 0xcc, 0x00, 0xcf, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x3f, 0xf8, 0x01, 0xfc, 0xc4, 0x00, 0x4f, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x01, 0xfc, 0xc2, 0x00, 0x47, 0xff, 0x80, 0x00, 0x1f, 
0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x01, 0xfc, 0xc0, 0x00, 0x47, 
0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xfc, 0x01, 
0xfc, 0x60, 0x00, 0x47, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xff, 0xff, 
0x80, 0x1f, 0xfc, 0x01, 0xfc, 0x20, 0x00, 0x43, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 
0x3f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xfc, 0x01, 0xfc, 0x30, 0x00, 0x43, 0xff, 0x80, 0x00, 0x3f, 
0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xfc, 0x01, 0xfc, 0x10, 0x00, 0x43, 
0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xfc, 0x01, 
0xfc, 0x18, 0x00, 0x83, 0xff, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 
0xc0, 0x1f, 0xf8, 0x01, 0xfc, 0x08, 0x00, 0x87, 0xff, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 
0x7f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xf8, 0x03, 0xfc, 0x08, 0x00, 0x07, 0xff, 0x00, 0x00, 0x7f, 
0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x1f, 0xf8, 0x03, 0xfe, 0x00, 0x00, 0x07, 
0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x3f, 0xf0, 0x03, 
0xfe, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xff, 0xfc, 
0x00, 0x3f, 0xf0, 0x03, 0xff, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x00, 
0x7f, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xf0, 0x07, 0xff, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x7f, 
0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0xff, 0xe0, 0x07, 0xff, 0x80, 0x00, 0x3f, 
0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xe0, 0x0f, 
0xff, 0xc0, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0x80, 0x00, 
0x01, 0xff, 0xc0, 0x0f, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 
0xff, 0xfe, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x0f, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x1f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x1f, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0xff, 0xe0, 0x00, 0x00, 
0x7f, 0xfe, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x01, 
0xff, 0xc0, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x3f, 
0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 
0x80, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0xff, 
0xfe, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xe0, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x01, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x3f, 
0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xfc, 0x00, 0x00, 0xff, 
0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x0f, 0xff, 
0xfc, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x03, 0xff, 0xff, 0xff, 0xff, 
0xe0, 0x00, 0x1f, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x03, 
0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x3f, 
0xff, 0xff, 0xf8, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfc, 0x00, 0x01, 0xff, 
0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xfc, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x03, 0xfe, 0x00, 0x00, 0x00, 
0x00, 0x03, 0xff, 0xff, 0xf8, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x07, 
0xfe, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x0f, 
0xff, 0xff, 0xf0, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x03, 0xff, 
0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 
0xf0, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x07, 0xfe, 0x00, 0x00, 0x00, 
0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x07, 
0xfc, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x07, 
0xff, 0xff, 0xf0, 0x07, 0xfc, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x07, 0xff, 
0xff, 0xe0, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x07, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xe0, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x0f, 0xfc, 0x01, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x0f, 
0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x07, 0xff, 0xff, 0xc0, 0x00, 0x03, 
0xff, 0xff, 0xe0, 0x0f, 0xf8, 0x01, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x01, 0xff, 
0xff, 0x80, 0x00, 0x01, 0xff, 0xff, 0xe0, 0x0f, 0xf8, 0x01, 0xfe, 0x03, 0xff, 0x00, 0x7f, 0xff, 
0x80, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x0f, 0xf8, 0x01, 0xfc, 0xf9, 
0xff, 0x3f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x0f, 
0xf8, 0x01, 0xf9, 0xfd, 0xff, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
0x7f, 0xff, 0xe0, 0x0f, 0xf8, 0x03, 0xf3, 0xff, 0xff, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 
0xf8, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x1f, 0xf8, 0x03, 0xf7, 0xff, 0xff, 0x7f, 0xff, 0xfe, 
0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x1f, 0xf8, 0x03, 0xf7, 0xff, 
0xff, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x1f, 
0xf0, 0x0f, 0xf7, 0xfd, 0xff, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 
0x1f, 0xff, 0xc0, 0x1f, 0xf0, 0x3f, 0xf7, 0xfd, 0xff, 0x3f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 
0xfe, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x1f, 0xf0, 0xff, 0xf3, 0xfd, 0xff, 0x7f, 0xff, 0xf0, 
0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x3f, 0xf1, 0xff, 0xf3, 0xfd, 
0xff, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x01, 0x80, 0x00, 0x07, 0xff, 0x80, 0x3f, 
0xf7, 0xff, 0xf9, 0xfd, 0xff, 0x7f, 0xff, 0xe0, 0x00, 0x01, 0xc0, 0xff, 0xff, 0x1f, 0x80, 0x00, 
0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbc, 0x70, 0xef, 0x00, 0x7f, 0xc0, 0x00, 0x01, 0xfe, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x07, 0xee, 0x00, 0x7f, 0x80, 
0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x7f, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 
0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 
0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 
0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x3f, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x1f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 
0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 
0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 
0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 
0x00, 0x00, 0x00, 0x1f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xfc, 0x00, 0x00, 0x00, 
0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf3, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 
0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 
0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 
0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 
0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x1f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x3c, 0x00, 0x03, 0xc0, 0x00, 
0x3e, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x7f, 
0xc0, 0x03, 0xc0, 0x07, 0xfe, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xf8, 0x00, 0x7f, 0xff, 0x83, 0xc1, 0xff, 0xff, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xc3, 0xc1, 0xff, 0xff, 0x80, 0x3f, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xc3, 0xc3, 0xff, 
0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 
0xff, 0xc3, 0xc3, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xc3, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xe3, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};



void LCD_SetInterfaceMode(uint8_t mode) {
    switch (mode) {
        case 0: // 4-wire SPI (IF1=0, IF0=0)
            HAL_GPIO_WritePin(IF1_PORT, IF1_PIN, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(IF0_PORT, IF0_PIN, GPIO_PIN_RESET);
						HAL_GPIO_WritePin(LCD_PORT_ERD , LCD_Pin_ERD, GPIO_PIN_SET);
            HAL_GPIO_WritePin(LCD_PORT_RWR, LCD_Pin_RWR, GPIO_PIN_SET);
				
						D4_HIGH();
						D5_HIGH();
						D6_HIGH();
						D7_HIGH();
				
				
				/*WR,ED connected together----D1,D2,D3connected together, -----,D6,D7 connected toghether*/
            break;
        case 1: // 3-wire SPI (IF1=0, IF0=1)
            HAL_GPIO_WritePin(IF1_PORT, IF1_PIN, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(IF0_PORT, IF0_PIN, GPIO_PIN_SET);
            break;
        case 2: // 6800 Parallel (IF1=1, IF0=0)
            HAL_GPIO_WritePin(IF1_PORT, IF1_PIN, GPIO_PIN_SET);
            HAL_GPIO_WritePin(IF0_PORT, IF0_PIN, GPIO_PIN_RESET);
            break;
        case 3: // 8080 Parallel (IF1=1, IF0=1)
            HAL_GPIO_WritePin(IF1_PORT, IF1_PIN, GPIO_PIN_SET);
            HAL_GPIO_WritePin(IF0_PORT, IF0_PIN, GPIO_PIN_SET);
            break;
    }
}

void MY_LED_POWER(GPIO_PinState Status){
	HAL_GPIO_WritePin(LED_PORT, LED_Pin, Status);
}

// Delay function
void delay_ms(uint32_t ms) {
    HAL_Delay(ms);
}

// GPIO-based SPI write
/*void write_byte(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        if (data & 0x80) {
            SDA_HIGH();
        } else {
            SDA_LOW();
        }
        SCL_HIGH();
        data <<= 1;
        SCL_LOW();
    }
}*/

void write_byte(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        if (data & 0x80) {
            SDA_HIGH();  // Set SDA HIGH if MSB is 1
						//D2_HIGH();
						//D3_HIGH();
        } else {
            SDA_LOW();   // Set SDA LOW if MSB is 0
						//D2_LOW();
						//D3_LOW();
        }

        SCL_HIGH();  // Clock pulse HIGH
        __NOP();  // Small delay (optional, ensures timing stability)
        SCL_LOW();  // Clock pulse LOW

        data <<= 1;  // Shift left for next bit
    }
}


// Write command to LCD
void write_command(uint8_t cmd) {
    CSB_LOW();
    A0_LOW();  // A0 = 0 for commands
    write_byte(cmd);
    CSB_HIGH();
}

// Write data to LCD
void write_data(uint8_t data) {
    CSB_LOW();
    A0_HIGH();  // A0 = 1 for data
    write_byte(data);
    CSB_HIGH();
}


void set_grayscale_levels(void) {
    write_command(0x31);  // EXT=1
    write_command(0x20);  // Set Gray Scale Level

    // Define 16 grayscale levels (for smooth transitions)
    write_data(0x00);
    write_data(0x05);
    write_data(0x0A);
    write_data(0x0F);
    write_data(0x14);
    write_data(0x19);
    write_data(0x1E);
    write_data(0x23);
    write_data(0x28);
    write_data(0x2D);
    write_data(0x32);
    write_data(0x37);
    write_data(0x3C);
    write_data(0x41);
    write_data(0x46);
    write_data(0x4B);
}

void lcd_reset() {
    RES_LOW();
    HAL_Delay(10);
    RES_HIGH();
    HAL_Delay(50);
}

void lcd_init(uint8_t grayscale) {
    lcd_reset();

    write_command(0x31);  // EXT=1
    write_command(0xD7);  // Disable Auto Read
    write_data(0x9F);    

    write_command(0xE0);  // Enable OTP Read
    write_data(0x00);
    HAL_Delay(10);
    write_command(0xE3);  // OTP Upload
    HAL_Delay(20);
    write_command(0xE1);  // OTP Control Out

    write_command(0x30);  // EXT=0
    write_command(0x94);  // Sleep Out
    write_command(0xAE);  // Display Off
    HAL_Delay(50);

    write_command(0x20);  // Power Control
    write_data(0x0B);     // Enable Regulator, Follower, Booster

    write_command(0x81);  // EV Control (Contrast)
    write_data(0x05);  // Lower contrast for grayscale
    write_data(0x05);  

    if (grayscale) {
        write_command(0xF0);  // Display Mode
        write_data(0x11);      // Enable 4-Gray Mode

        write_command(0x31);  // EXT=1
        write_command(0x40);  // Internal Power Supply

        // Set grayscale voltage levels (with EXT=1)
        write_command(0x20);  
        write_data(0x00);  // Black
        write_data(0x17);  // Dark Gray (changed)
        write_data(0x1D);  // Light Gray (changed)
        write_data(0x3F);  // White (higher brightness)

        write_command(0x32);  // Analog Circuit Set
        write_data(0x00);
        write_data(0x01);
        write_data(0x02);

        write_command(0x51);  // Booster Level x10
        write_data(0xFB);

        write_command(0x30);  // EXT=0
    } else {
        write_command(0xF0);  // Display Mode
        write_data(0x10);     // Monochrome Mode
    }

    write_command(0xCA);  // Display Control (Frame Inversion)
    write_data(0x00);
    write_data(0x9F);
    write_data(0x25);

    write_command(0xBC);  // Data Scan Direction
    write_data(0x00);     // Normal scan direction

    write_command(0xAF);  // Display ON
}


void lcd_fill_gray(uint8_t gray_level) {
    uint8_t pixel_value;

    // Ensure grayscale mode is enabled before filling
    write_command(0x30);  // EXT=0
    write_command(0xF0);  // Display Mode
    write_data(0x11);     // 4-Gray Mode

    // Convert grayscale level to 2-bit encoding
    switch (gray_level) {
        case 3: pixel_value = 0xFF; break;  // BLACK (11 11 11 11)
        case 2: pixel_value = 0xAA; break;  // Light Gray (10 10 10 10))
        case 1: pixel_value = 0x55; break;  // Dark Gray (01 01 01 01)
        case 0: pixel_value = 0x00; break;  // White  (00 00 00 00)
        default: pixel_value = 0x00; break; // Default to white
    }

    // Set row address (entire screen)
    write_command(0x75);
    write_data(0x00);   // Start row
    write_data(0x27);   // End row (160 pixels)

    // Set column address (entire screen)
    write_command(0x15);
    write_data(0x00);   // Start column
    write_data(0x9F);   // End column (160 pixels)

    // Start writing to DDRAM
    write_command(0x5C);

    // Fill the screen with the selected grayscale level
    for (uint32_t i = 0; i < (160 * 160 / 4); i++) {  
        write_data(pixel_value);  // Fill each byte (4 pixels per byte)
    }
}

// LCD initialization function


void ST75161_init(void) {
    // Reset the LCD
    RES_HIGH();
    delay_ms(50);
    RES_LOW();
    delay_ms(20);
    RES_HIGH();
    delay_ms(200);

    // Start initialization sequence
    write_command(0x31);    // EXT=1
    write_command(0xD7);    // Disable Auto Read
    write_data(0x9F);       // Data for D7 command

    write_command(0xE0);    // Enable OTP Read
    write_data(0x00);
    delay_ms(10);
    write_command(0xE3);    // OTP Upload
    delay_ms(20);
    write_command(0xE1);    // OTP Control Out

    write_command(0x30);    // EXT=0
    write_command(0x94);    // Sleep Out
    write_command(0xAE);    // Display Off
    delay_ms(50);

    write_command(0x20);    // Power Control
    write_data(0x0B);       // Regulator, follower, booster on

    write_command(0x81);    // EV Control
    write_data(0x05);       // VPR[5-0]
    write_data(0x05);       // VPR[8-6]

    write_command(0x31);    // EXT=1
    write_command(0x20);    // Set Gray Scale Level
		write_data(0x00);
		write_data(0x00);
		write_data(0x00);
		write_data(0x17);
		write_data(0x17);
		write_data(0x17);
		write_data(0x00);
		write_data(0x00);
		write_data(0x1d);
		write_data(0x00);
		write_data(0x00);
		write_data(0x1d);
		write_data(0x1d);
		write_data(0x1d);
		write_data(0x00);
		write_data(0x00);

    write_command(0x32);    // Analog Circuit Set
    write_data(0x00);       // Default settings
    write_data(0x01);       // Booster efficiency
    write_data(0x02);       // Bias

    write_command(0x51);    // Booster Level x10
    write_data(0xFB);

    write_command(0x30);    // EXT=0

    write_command(0xF0);    // Display Mode
    write_data(0x10);       // Monochrome mode

    write_command(0xCA);    // Display Control
    write_data(0x00);       // No CL dividing ratio
    write_data(0x9F);       // Duty set
    write_data(0x25);       // Frame inversion

    write_command(0xBC);    // Data Scan Direction
    write_data(0x00);  // Normal scan direction (left to right)
		//write_data(0x02);  // Reverse scan direction (right to left)

    write_command(0xA6);    // Normal display mode

    write_command(0xAF);    // Display On


}
void flip_display_horizontal(uint8_t enable) {
    write_command(0xBC);
    if (enable) {
        write_data(0x02);  // Enable right-to-left
    } else {
        write_data(0x00);  // Normal left-to-right
    }
}
void flip_display_vertical(uint8_t enable) {
    write_command(0xBC);
    if (enable) {
        write_data(0x01);  // Enable bottom-to-top
    } else {
        write_data(0x00);  // Normal top-to-bottom
    }
}
// Clear the DDRAM
void ST75161_clear(void) {
		write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	// Monochrome Mode
    write_command(0x15);  // Column address
    write_data(0x00);
    write_data(0x9F);

    write_command(0x75);  // Row address
    write_data(0x00);
    write_data(0x27);

    write_command(0x5C);  // Write RAM command

    for (int i = 0; i < (160 * 160 / 8); i++) {  
    write_data(0x00);  // Write full black
}
}
void ST75161_clear_area(uint8_t x_start, uint8_t y_start, uint8_t width, uint8_t height) {
		write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	// Monochrome Mode
    write_command(0x15);  // Column address
    write_data(x_start);
    write_data(x_start+width-1);

    write_command(0x75);  // Row address
    write_data(y_start);
    write_data(y_start+height-1);

    write_command(0x5C);  // Write RAM command

    for (int i = 0; i < (x_start * y_start ); i++) {  
    write_data(0x00);  // Write full black
}
}
void Fill_BLACK(void) {
		write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	// Monochrome Mode
	
    write_command(0x15);  // Column address
    write_data(0x00);
    write_data(0x9F);

    write_command(0x75);  // Row address
    write_data(0x00);
    write_data(0x13);  //19 row for monochrome mode 

    write_command(0x5C);  // Write RAM command

    for (int i = 0; i < (160 * 160 / 8); i++) {  
    write_data(0xFF);  // Write full black
	}
}

void Fill_8_row(int row,int column) {
		write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	// Monochrome Mode
	
    write_command(0x15);  // Column address
    write_data(column);
    write_data(column);

    write_command(0x75);  // Row address
    write_data(row);
    write_data(row);  //19 row for monochrome mode 

    write_command(0x5C);  // Write RAM command
		write_data(0xFF);  // Write full black
   
}


void lcd_draw_black_box() {
    write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	// Monochrome Mode


    write_command(0x75);  // Set row address
    write_data(0);   // Start row
    write_data(10);   // End row

    write_command(0x15);  // Set column address
    write_data(0);  // Start column
    write_data(50);  // End column

    write_command(0x5C);  // Start writing to DDRAM
		for (int i = 0; i < (160 * 160 / 4); i++) {  // 2-bit per pixel ? 4 pixels per byte
				//D7 D6 D5 D4 D3 D2 D1 D0 //for monochrome 8pixel=1byte  for grayscal 4pixel =1byte
        write_data(0b10011100);  // Alternating grayscale (light/dark)
    }

}
void lcd_draw_black_box_gray() {
    write_command(0x30);  // EXT=0
    write_command(0xF0);  // Display Mode
    write_data(0x11);     // Enable 4-Gray Mode

    write_command(0x31);  // EXT=1
    write_command(0x40);  // Internal Power Supply

    // Set grayscale voltage levels
    write_command(0x20);  
    write_data(0x00);  // Black
    write_data(0x55);  // Dark Gray
    write_data(0xAA);  // Light Gray
    write_data(0xFF);  // White

    write_command(0x30);  // EXT=0

    // Adjust contrast (important for grayscale mode)
    write_command(0x81);  
    write_data(0x30);  // Contrast (adjustable: 0x30 to 0x50)
    write_data(0x30);  

    write_command(0xAF);  // Display ON (make sure this is called!)

     // Set row address
    write_command(0x75);
    write_data(0);   // Start row
    write_data(10);  // End row

    // Set column address
    write_command(0x15);
    write_data(0);   // Start column
    write_data(50);  // End column

    // Start writing to DDRAM
    write_command(0x5C);

    for (int i = 0; i < (160 * 160 / 4); i++) {  // 2-bit per pixel -> 4 pixels per byte
        write_data(0b00011011);  // 4 pixels: [Black, Dark Gray, Light Gray, White]
    }

}

void lcd_draw_rect_gray(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t gray_level) {
    uint8_t pixel_value;

    // Ensure grayscale mode is enabled before drawing
    write_command(0x30);  // EXT=0
    write_command(0xF0);  // Display Mode
    write_data(0x11);     // 4-Gray Mode

    // Convert grayscale level to 2-bit encoding
    switch (gray_level) {
        case 3: pixel_value = 0xFF; break;  // BLACK (11 11 11 11)
        case 2: pixel_value = 0xAA; break;  // Medium Gray (10 10 10 10)
        case 1: pixel_value = 0x55; break;  // Light Gray (01 01 01 01)
        case 0: pixel_value = 0x00; break;  // White (00 00 00 00)
        default: pixel_value = 0x00; break; // Default to white
    }

    // Set column address
    write_command(0x15);
    write_data(x);               // Start column
    write_data(x + width - 1);   // End column

    // Set row address
    write_command(0x75);
    write_data(y / 4);           // Start row (divided by 4 for 4-pixel grouping)
    write_data((y + height - 1) / 4); // End row

    // Start writing to DDRAM
    write_command(0x5C);

    // Fill the rectangle with the selected grayscale level
    for (uint16_t i = 0; i < (width * height / 4); i++) {  
        write_data(pixel_value);  // Fill each byte (4 pixels per byte)
    }
}

void lcd_draw_rectangle(uint8_t x_start, uint8_t y_start, uint8_t width, uint8_t height) {
    if (y_start + height > 20) {  // Ensure we don't exceed row limit
        height = 20 - y_start;
    }

    write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	    // Monochrome Mode

    write_command(0x75);  // Set row address
    write_data(y_start);   // Start row
    write_data(y_start + height - 1);   // End row

    write_command(0x15);  // Set column address
    write_data(x_start);  // Start column
    write_data(x_start + width - 1);  // End column

    write_command(0x5C);  // Start writing to DDRAM
		for (int i = 0; i < (160 * 160 / 8); i++) {  
			write_data(0xFF);  // Write full black
		}
}

void lcd_draw_rectangle_border(uint8_t x_start, uint8_t y_start, uint8_t width, uint8_t height, uint8_t thickness) {
    if (y_start + height > 20) {  // Ensure we don't exceed row limit
        height = 20 - y_start;
    }

    write_command(0x30);   	// EXT=0 
    write_command(0xf0);   	// Display Mode
    write_data(0x10);	    // Monochrome Mode

    // Draw top border
    write_command(0x75);  
    write_data(y_start);   // Start row
    write_data(y_start + thickness - 1);   // End row (top border thickness)
    write_command(0x15);  
    write_data(x_start);  
    write_data(x_start + width - 1);
    write_command(0x5C);  
    for (int i = 0; i < (160 * 160 / 8); i++) {  
			write_data(0xFF);  // Write full black
		}

    // Draw bottom border
    write_command(0x75);  
    write_data(y_start + height - thickness);  
    write_data(y_start + height - 1);  
    write_command(0x15);  
    write_data(x_start);  
    write_data(x_start + width - 1);
    write_command(0x5C);  
    for (int i = 0; i < (160 * 160 / 8); i++) {  
			write_data(0xFF);  // Write full black
		}

    // Draw left and right borders
    for (int row = y_start + thickness; row < y_start + height - thickness; row++) {
        write_command(0x75);  
        write_data(row);  
        write_data(row);  // Only draw one row at a time

        write_command(0x15);  
        write_data(x_start);  
        write_data(x_start + thickness - 1);  // Left border
        write_command(0x5C);  
        for (int j = 0; j < (thickness / 8) + 1; j++) {  
            write_data(0xFF);
        }

        write_command(0x15);  
        write_data(x_start + width - thickness);  
        write_data(x_start + width - 1);  // Right border
        write_command(0x5C);  
        for (int i = 0; i < (160 * 160 / 8); i++) {  
					write_data(0xFF);  // Write full black
			}
    }
}



void lcd_update_screen(void) {
    write_command(0x30);   // EXT=0
    write_command(0xf0);   // Display Mode
    write_data(0x10);      // Monochrome Mode

    for (uint8_t row = 0; row < 20; row++) {  // Iterate over row blocks (20  8 = 160 rows)
        write_command(0x75);
        write_data(row);
        write_data(row);

        write_command(0x15);
        write_data(0);
        write_data(159);

        write_command(0x5C);  // Start writing to DDRAM

        for (uint8_t col = 0; col < 160; col++) {
            write_data(lcd_buffer[row][col]);  // Send buffer row data
        }
    }
}
void lcd_set_pixel(uint8_t x, uint8_t y, uint8_t color) {
    if (x >= 160 || y >= 160) return;  // Out of bounds

    uint8_t row = y / 8;  // Find which row group (8 pixels high) this belongs to
    uint8_t bit_position = y % 8;  // Determine exact bit in the byte

    if (color) {
        lcd_buffer[row][x] |= (1 << bit_position);  // Turn pixel ON
    } else {
        lcd_buffer[row][x] &= ~(1 << bit_position);  // Turn pixel OFF
    }

    write_command(0x75);
    write_data(row);  
    write_data(row);  // Only update this row group

    write_command(0x15);
    write_data(x);
    write_data(x);

    write_command(0x5C);
    write_data(lcd_buffer[row][x]);  // Send only updated column data
}

void lcd_set_pixel_gray(uint8_t x, uint8_t y, uint8_t gray_level) {
    if (x >= 160 || y >= 160) return;  // Boundary check

    uint16_t byte_index = (y / 4) * 160 + x;  // Find correct byte
    uint8_t pixel_shift = (y % 4) * 2;  // Determine 2-bit position

    // Clear previous pixel value
    lcd_buffer_gray[byte_index] &= ~(0x03 << pixel_shift);
    // Set new grayscale value
    lcd_buffer_gray[byte_index] |= (gray_level & 0x03) << pixel_shift;

    // Update only the modified pixel on LCD
    write_command(0x75);
    write_data(y / 4);  
    write_data(y / 4);  

    write_command(0x15);
    write_data(x);
    write_data(x);

    write_command(0x5C);
    write_data(lcd_buffer_gray[byte_index]);  // Update only this byte
}


void lcd_draw_char(uint8_t x, uint8_t y, char c, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    // Check if the character is within the valid range (assuming ASCII 32127)
    if (c < 32 || c > 127) return;

    // Convert ASCII to font array index (assuming font starts at ASCII 32)
    uint8_t font_index = c - 32;

    // Set column address
    write_command(0x15);  // Set column address
    write_data(x);
    write_data(x + font_width - 1);  // Use font_width for the end column

    // Set row address
    write_command(0x75);  // Set row address
    write_data(y / 8);
    write_data((y + font_height - 1) / 8);  // Adjust for font height (spanning rows)

    // Start writing to DDRAM
    write_command(0x5C);

    // Draw the character column by column
    for (uint8_t col = 0; col < font_width; col++) {
        uint8_t column_data = font[font_index * font_width + col];  // Access correct column

        for (uint8_t row = 0; row < font_height; row++) {  // Use font_height for rows
            if (column_data & (1 << row)) {
                lcd_set_pixel(x + col, y + row, 1);  // Turn ON pixel
            }
        }
    }
}


void lcd_draw_string(uint8_t x, uint8_t y, char *str, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    while (*str) {
        lcd_draw_char(x, y, *str, font, font_width, font_height);  // Draw each character
        x += font_width + 1;  // Move to the next character (font_width + 1 pixel spacing)
        str++;
    }
}

void lcd_draw_char_bold(uint8_t x, uint8_t y, char c, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    if (c < 32 || c > 127) return;  // Ensure character is in range
    uint8_t font_index = c - 32;

    // Set column address
    write_command(0x15);  
    write_data(x);
    write_data(x + (font_width * 2) - 1);  // Double width for bold effect

    // Set row address
    write_command(0x75);
    write_data(y / 8);
    write_data((y + font_height - 1) / 8);

    // Start writing to DDRAM
    write_command(0x5C);

    for (uint8_t col = 0; col < font_width; col++) {
        uint8_t column_data = font[font_index * font_width + col];

        for (uint8_t row = 0; row < font_height; row++) {
            if (column_data & (1 << row)) {
                // Draw original pixel
                lcd_set_pixel(x + (col * 2), y + row, 1);
                // Draw an extra pixel to make it bold
                lcd_set_pixel(x + (col * 2) + 1, y + row, 1);
            }
        }
    }
}



void lcd_draw_string_bold(uint8_t x, uint8_t y, char *str, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    while (*str) {
        lcd_draw_char_bold(x, y, *str, font, font_width, font_height);
        x += (font_width * 2) + 1;  // Increase spacing for bold effect
        str++;
    }
}

void lcd_draw_char_inverted(uint8_t x, uint8_t y, char c, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    if (c < 32 || c > 127) return;  // Ensure character is in range
    uint8_t font_index = c - 32;

    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + font_width - 1);

    // Set row address
    write_command(0x75);
    write_data(y);
    write_data(y + font_height - 1);

    // Start writing to DDRAM (Black Background First)
    write_command(0x5C);
    for (uint8_t col = 0; col < font_width; col++) {
        write_data(0xFF);  // Fill black background
    }

    // Now draw the character in white (invert pixel bits)
    for (uint8_t col = 0; col < font_width; col++) {
        uint8_t column_data = font[font_index * font_width + col];

        // Invert the column data (swap black & white)
        column_data = ~column_data;

        for (uint8_t row = 0; row < font_height; row++) {
            if (column_data & (1 << row)) {  // If pixel should be ON (white)
                lcd_set_pixel(x + col, y + row, 1);  // WHITE pixel on BLACK background
            }
        }
    }
}




void lcd_draw_string_inverted(uint8_t x, uint8_t y, char *str, const uint8_t *font, uint8_t font_width, uint8_t font_height) {
    while (*str) {
        lcd_draw_char_inverted(x, y, *str, font, font_width, font_height);
        x += font_width + 1;  // Move to the next character
        str++;
    }
}

// Function to display an image on the ST75161 LCD
void ST75161_show_image(uint8_t *image, uint8_t width, uint8_t height) {
    if (width > 160 || height > 160) {
        // Make sure the image fits within the display size (160x160)
        return;
    }

    // Iterate through each pixel of the image
    for (uint8_t y = 0; y < height; y++) {
        for (uint8_t x = 0; x < width; x++) {
            // Get the pixel color from the image array (1 for ON, 0 for OFF)
            uint8_t color = (image[y * width + x] != 0) ? 1 : 0;
            // Set the pixel on the LCD
            lcd_set_pixel(x, y, color);
        }
    }
}
uint8_t reverse_byte(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

void lcd_draw_bitmap_Reverse(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t width, uint8_t height) {
    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + width - 1);

    // Set row address
    write_command(0x75);
    write_data(y);
    write_data(y + (height / 8) - 1);

    // Start writing to DDRAM
    write_command(0x5C);

    // Send bitmap data with flipped bits
    for (uint16_t i = 0; i < (width * (height / 8)); i++) {
        write_data(reverse_byte(bitmap[i]));  // Flip the bits inside each byte
    }
}

void lcd_draw_bitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t width, uint8_t height) {
	
		write_command(0x30);   // EXT=0
    write_command(0xf0);   // Display Mode
    write_data(0x10);      // monochrom
    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + width - 1);

    // Set row address
    write_command(0x75);
    write_data(y);
    write_data(y + (height / 8) - 1);

    // Start writing to DDRAM
    write_command(0x5C);

    // Send bitmap data
    for (uint16_t i = 0; i < (width * (height / 8)); i++) {
        write_data(bitmap[(width * (height / 8))-i]);
    }
}

void lcd_draw_bitmap_gray(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t width, uint8_t height) {
    uint8_t start_page = y / 4;
    uint8_t end_page = (y + height - 1) / 4;
    uint16_t total_bytes = width * ((height + 3) / 4); // Corrected for ceiling division

    // Ensure grayscale mode is enabled
    write_command(0x30); // EXT=0
    write_command(0xF0); // Display Mode
    write_data(0x11); // 4-Gray Mode

    // Set page address
    write_command(0x75);
    write_data(start_page);
    write_data(end_page);

    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + width - 1);

    // Start writing to DDRAM
    write_command(0x5C);

    // Send grayscale image data
    for (uint16_t i = 0; i < total_bytes; i++) {
        write_data(bitmap[i]);
    }
}
void lcd_set_pixel_gray2(uint8_t x, uint8_t y, uint8_t gray_level) {
    if (x >= 160 || y >= 161) return;
    uint16_t byte_index = (y / 4) * 160 + x;
    uint8_t pixel_shift = (y % 4) * 2;
    lcd_buffer_gray[byte_index] &= ~(0x03 << pixel_shift);
    lcd_buffer_gray[byte_index] |= (gray_level & 0x03) << pixel_shift;
    write_command(0x75); write_data(y / 4); write_data(y / 4);
    write_command(0x15); write_data(x); write_data(x);
    write_command(0x5C); write_data(lcd_buffer_gray[byte_index]);
}


// Function to convert standard font to gray-scale font
void convertFontToGray(const uint8_t font5x7[][5], uint16_t font5x7_gray[][5], int numChars, uint8_t level) {
    for (int charIndex = 0; charIndex < numChars; ++charIndex) {
        for (int col = 0; col < 5; ++col) {
            uint16_t grayCol = 0; // 16-bit value for the column
            
            // Process each row (0 to 7, with row 7 always off)
            for (int row = 0; row < 8; ++row) {
                uint8_t grayLevel;
                if (row < 7) {
                    // For rows 0 to 6, map from standard font
                    bool pixelOn = (font5x7[charIndex][col] & (1 << row)) != 0;
                    //grayLevel = pixelOn ? 3 : 0; // On -> gray level 3, off -> 0
										grayLevel = pixelOn ? level : 0; // Select user-defined gray level
                } else {
                    // Row 7 is always off
                    grayLevel = 0;
                }
                // Shift and set the gray level (2 bits per row)
                grayCol |= (grayLevel & 0x03) << (row * 2);
            }
            
            // Store the 16-bit value in the gray-scale font
            font5x7_gray[charIndex][col] = grayCol;
        }
    }
}

// Function to convert standard font to gray-scale font
void convertFont(const uint8_t font5x7[][5], uint16_t font5x7_gray[][5], int numChars) {
    for (int charIndex = 0; charIndex < numChars; ++charIndex) {
        for (int col = 0; col < 5; ++col) {
            uint16_t grayCol = 0; // 16-bit value for the column
            
            // Process each row (0 to 7, with row 7 always off)
            for (int row = 0; row < 8; ++row) {
                uint8_t grayLevel;
                if (row < 7) {
                    // For rows 0 to 6, map from standard font
                    bool pixelOn = (font5x7[charIndex][col] & (1 << row)) != 0;
                    grayLevel = pixelOn ? 3 : 0; // On -> gray level 3, off -> 0
                } else {
                    // Row 7 is always off
                    grayLevel = 0;
                }
                // Shift and set the gray level (2 bits per row)
                grayCol |= (grayLevel & 0x03) << (row * 2);
            }
            
            // Store the 16-bit value in the gray-scale font
            font5x7_gray[charIndex][col] = grayCol;
        }
    }
}


void lcd_draw_char_gray(uint8_t x, uint8_t y, char c, const uint16_t *font, uint8_t font_width, uint8_t font_height, uint8_t grayLevel) {
    if (c < 32 || c > 127) return;  // Ensure within ASCII range

    uint8_t font_index = c - 32;

    // Ensure grayLevel is within valid range (0 to 3)
    if (grayLevel > 3) grayLevel = 3;

    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + font_width - 1);

    // Set row address (top 4 pixels)
    write_command(0x75);
    write_data(y / 4);
    write_data(y / 4);

    // Start writing to DDRAM
    write_command(0x5C);

    // Draw upper 4-pixel block (first byte)
    for (uint8_t col = 0; col < font_width; col++) {
        uint16_t column_data = font[font_index * font_width + col];
        uint16_t new_column_data = 0;

        for (uint8_t row = 0; row < 7; row++) {  // 7 rows per column
            uint8_t pixelBits = (column_data >> (row * 2)) & 0x03; // Extract 2-bit value

            // Adjust grayscale level
            if (pixelBits == 0b11) { // If fully dark
								if (grayLevel == 3) pixelBits = 0b11; //fully dark
                if (grayLevel == 2) pixelBits = 0b10; // Reduce darkness
                if (grayLevel == 1) pixelBits = 0b01; // Even lighter
								if (grayLevel == 0) pixelBits = 0b00; // Fully off
            }

            // Reconstruct new column data
            new_column_data |= (pixelBits & 0x03) << (row * 2);
        }

        write_data((new_column_data >> 8) & 0xFF);  // Upper 8 bits
    }

    // Set column address again
    write_command(0x15);
    write_data(x);
    write_data(x + font_width - 1);

    // Set row address (bottom 4 pixels)
    write_command(0x75);
    write_data((y / 4) + 1);
    write_data((y / 4) + 1);

    // Start writing to DDRAM
    write_command(0x5C);

    // Draw lower 4-pixel block (second byte)
    for (uint8_t col = 0; col < font_width; col++) {
        uint16_t column_data = font[font_index * font_width + col];
        uint16_t new_column_data = 0;

        for (uint8_t row = 0; row < 7; row++) {
            uint8_t pixelBits = (column_data >> (row * 2)) & 0x03;

            // Adjust grayscale level
            if (pixelBits == 0b11) { // If fully dark
								if (grayLevel == 3) pixelBits = 0b11; //fully dark
                if (grayLevel == 2) pixelBits = 0b10; // Reduce darkness
                if (grayLevel == 1) pixelBits = 0b01; // Even lighter
								if (grayLevel == 0) pixelBits = 0b00; // Fully off
            }

            // Reconstruct new column data
            new_column_data |= (pixelBits & 0x03) << (row * 2);
        }

        write_data(new_column_data & 0xFF);  // Lower 8 bits
    }
}

void lcd_draw_char_gray_background(uint8_t x, uint8_t y, char c, const uint16_t *font, uint8_t font_width, uint8_t font_height, uint8_t grayLevel, uint8_t bgGrayLevel, bool invert) {
    if (c < 32 || c > 127) return;  // Ensure within ASCII range

    uint8_t font_index = c - 32;

    // Ensure gray levels are within valid range (0 to 3)
    grayLevel = (grayLevel > 3) ? 3 : grayLevel;
    bgGrayLevel = (bgGrayLevel > 3) ? 3 : bgGrayLevel;

    // ?? Step 1: Draw Background First
    lcd_draw_rect_gray(x, y, font_width, font_height, bgGrayLevel);

    // Set column address
    write_command(0x15);
    write_data(x);
    write_data(x + font_width - 1);

    // Set row address (top 4 pixels)
    write_command(0x75);
    write_data(y / 4);
    write_data(y / 4);

    // Start writing to DDRAM
    write_command(0x5C);

    // ?? Step 2: Draw Character with Proper Foreground & Background
    for (uint8_t col = 0; col < font_width; col++) {
        uint16_t column_data = font[font_index * font_width + col];
        uint16_t new_column_data = 0;

        for (uint8_t row = 0; row < font_height; row++) {
            uint8_t pixelBits = (column_data >> (row * 2)) & 0x03;  // Extract 2-bit value (grayscale)

            // ? Correct grayscale handling
            if (invert) {
                pixelBits = (pixelBits == 0b11) ? bgGrayLevel : grayLevel;  // Swap foreground and background
            } else {
                pixelBits = (pixelBits == 0b11) ? grayLevel : bgGrayLevel;  // Normal mode
            }

            // Reconstruct new column data
            new_column_data |= (pixelBits & 0x03) << (row * 2);
        }

        write_data((new_column_data >> 8) & 0xFF);  // Upper 8 bits
    }

    // Set column address again
    write_command(0x15);
    write_data(x);
    write_data(x + font_width - 1);

    // Set row address (bottom 4 pixels)
    write_command(0x75);
    write_data((y / 4) + 1);
    write_data((y / 4) + 1);

    // Start writing to DDRAM
    write_command(0x5C);

    // ?? Step 3: Draw Lower 4-Pixel Block
    for (uint8_t col = 0; col < font_width; col++) {
        uint16_t column_data = font[font_index * font_width + col];
        uint16_t new_column_data = 0;

        for (uint8_t row = 0; row < font_height; row++) {
            uint8_t pixelBits = (column_data >> (row * 2)) & 0x03;

            if (invert) {
                pixelBits = (pixelBits == 0b11) ? bgGrayLevel : grayLevel;
            } else {
                pixelBits = (pixelBits == 0b11) ? grayLevel : bgGrayLevel;
            }

            new_column_data |= (pixelBits & 0x03) << (row * 2);
        }

        write_data(new_column_data & 0xFF);  // Lower 8 bits
    }
}





void lcd_draw_string_gray(uint8_t x, uint8_t y, char *str, const uint16_t *font, uint8_t font_width, uint8_t font_height, uint8_t gray_level) {
    while (*str) {
        lcd_draw_char_gray(x, y, *str, font, font_width, font_height,gray_level);
        x += font_width + 1;  // Move cursor for next character
        str++;
    }
}






